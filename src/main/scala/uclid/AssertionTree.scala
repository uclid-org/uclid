/*
 * UCLID5 Verification and Synthesis Engine
 *
 * Copyright (c) 2017.
 * Sanjit A. Seshia, Rohit Sinha and Pramod Subramanyan.
 *
 * All Rights Reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 *
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: Pramod Subramanyan

 * Class that manages proof obligations generated by UCLID5.
 *
 */

package uclid

import uclid.lang._
import com.typesafe.scalalogging.Logger
import scala.collection.mutable.ListBuffer

case class AssertInfo(
    name : String, label : String,
    frameTable : SymbolicSimulator.SimulationTable,
    context : Scope,
    iter : Int,
    pathCond : smt.Expr,
    expr : smt.Expr,
    decorators : List[ExprDecorator],
    pos : ASTPosition) {
  def withNewFrameTable() : AssertInfo = {
    AssertInfo(name, label, frameTable.clone(), context, iter, pathCond, expr, decorators, pos)
  }
  override def toString = {
    label + " [Step #" + iter.toString + "] " + name + " @ " + pos.toString
  }
}

case class CheckResult(assert : AssertInfo, result : smt.SolverResult)

class AssertionTree {
  val log = Logger(classOf[AssertionTree])
  class TreeNode(p : Option[TreeNode], assumps : List[smt.Expr]) {
    var parent : Option[TreeNode] = p // Root does not have a parent, so parent = None for root and Some(p) for all other nodes.
    var children : ListBuffer[TreeNode] = ListBuffer.empty
    var assumptions: Set[smt.Expr] = {
      p match {
        case None => assumps.toSet
        case Some(node) => assumps.filter(e => !node.isAssumptionInScope(e)).toSet
      }
      
    }
    var assertions: ListBuffer[AssertInfo] = ListBuffer.empty
    var results : List[CheckResult] = List.empty

    def isAssumptionInScope(e : smt.Expr) : Boolean = {
      if (assumptions.contains(e)) true
      else {
        parent match {
          case Some(node) => node.isAssumptionInScope(e)
          case None => false
        }
      }
    }

    // these two functions add assumptions.
    def +=(e : smt.Expr) {
      if (!isAssumptionInScope(e)) {
        assumptions += e
      }
    }
    // and these two add assertions
    def +=(assert: AssertInfo) { assertions += assert }
  }

  val root : TreeNode = new TreeNode(None, List.empty)
  val initialRoot : TreeNode = root
  var currentNode : TreeNode = root

  /** Helper function to create a new child node. */
  def newChildNode() {
    val childNode = new TreeNode(Some(currentNode), List.empty)
    currentNode.children += childNode
    currentNode = childNode
  }

  /** This function should be called for each separate verificaiton task.
   *
   *  It ensures that assumptions are not reused across procedures or
   *  other verification tasks.
   */
  def startVerificationScope() {
    newChildNode()
  }

  def addAssumption(assump: smt.Expr) {
    if (currentNode.assertions.size > 0) {
      newChildNode()
    }
    currentNode += assump
  }

  def addAssert(assert: AssertInfo) {
    log.debug("assert: {}; iter: {}; size: {}",
        assert.expr.toString(), assert.iter, SymbolicSimulator.simRecordLength(assert.frameTable))
    log.debug("frameTable: {}", assert.frameTable.toString())
    Utils.assert(
        assert.iter + 1 <= SymbolicSimulator.simRecordLength(assert.frameTable),
        "Invalid length/step combination")
    currentNode += assert
  }

  def resetToInitial() {
    currentNode = initialRoot
  }

  sealed abstract class VerifyMode {
    val isAssert : Boolean
  }
  case object VerifyModeAssert extends VerifyMode {
    override val isAssert = true
  }
  case object VerifyModePreprocess extends VerifyMode {
    override val isAssert = false
  }

  def _verify(node : TreeNode, solver : smt.Context, mode : VerifyMode, getModel : Boolean) : List[CheckResult] = {
    if (mode.isAssert) {
      solver.push()
      node.assumptions.foreach(a => solver.assert(a))
    } else {
      node.assumptions.foreach(a => solver.preassert(a))
    }
    val results = (node.assertions.map {
      e => {
        val pcExpr = e.pathCond
        // If assertExpr has a CoverDecorator then we should not negate the expression here.
        val assertExpr = if (e.decorators.contains(CoverDecorator)) {
          e.expr
        } else {
          smt.OperatorApplication(smt.NegationOp, List(e.expr))
        }
        val checkExpr = if (pcExpr == smt.BooleanLit(true)) {
          assertExpr
        } else {
          smt.OperatorApplication(smt.ConjunctionOp, List(pcExpr, assertExpr))
        }
        if (mode.isAssert) {
          val start = System.nanoTime()
          UclidMain.printStats(f"Starting solver on: " + e.toString)
          solver.push()
          solver.assert(checkExpr)
          solver.curAssertName = e.name
          solver.curAssertLabel = e.label
          val sat = solver.check(getModel)
          val delta =  (System.nanoTime() - start) / 1000000.0
          UclidMain.printStats(f"Solver finished in $delta%.1f ms")
          val result = sat.result match {
            case Some(true)  => smt.SolverResult(Some(false), sat.model)
            case Some(false) => smt.SolverResult(Some(true), sat.model)
            case None        => smt.SolverResult(None, None)
          }
          solver.pop()
          Some(CheckResult(e, result))
        } else {
          solver.preassert(checkExpr)
          None
        }
      }
    }).toList
    if (mode.isAssert) {
      node.results = results.flatten
    }
    // now recurse into children
    if (mode.isAssert) {
        val childResults = node.children.flatMap(c => _verify(c, solver, mode, getModel))
        solver.pop()
        node.results ++ childResults
    } else {
        node.children.foreach(c => _verify(c, solver, mode, getModel))
        List.empty
    }
  }
  def verify(solver : smt.Context, getModel: Boolean) : List[CheckResult] = {
    _verify(root, solver, VerifyModePreprocess, getModel)
    _verify(root, solver, VerifyModeAssert, getModel)
  }

  def _printSMT(node : TreeNode, parentAssumptions : List[smt.Expr], label : Option[Identifier], solver : smt.SolverInterface) : List[String] = {
    val allAssumptions = parentAssumptions ++ node.assumptions.toList
    val filteredAssertions = (label match {
      case None        => node.assertions
      case Some(label) =>
        node.assertions.filter{e => e.label == label.name}
    }).toList

    val theseSMTFormulas = filteredAssertions.map{
      a => {
        val name = label match {
          case None => "uclid: [%s]; step %d".format(a.pos.toString, a.iter)
          case Some(label) => "uclid(%s): [%s]; step %d".format(label, a.pos.toString, a.iter)
        }
        solver.toSMT2(smt.OperatorApplication(smt.ConjunctionOp, List(a.pathCond, a.expr)),
                      allAssumptions, name)
      }
    }
    val childResults = node.children.flatMap(c => _printSMT(c, allAssumptions, label, solver))
    theseSMTFormulas ++ childResults
  }
  def printSMT(label : Option[Identifier], solver : smt.SolverInterface) = _printSMT(root, List.empty, label, solver)
}
